/***************************** doc/gen.doc *************************************

	Copyright (c) 1997 A. Krall, R. Grafl, M. Gschwind, M. Probst

	See file COPYRIGHT for information on usage and disclaimer of warranties

	Enth"alt die Beschreibung der Schnittstelle zwischen dem systemUNabh"angigen
	und dem systemABh"angigen Teil des Compilers.

	Authors: Reinhard Grafl      EMAIL: cacao@complang.tuwien.ac.at

	Last Change: 1997/03/05

*******************************************************************************/

Der gr"osste Teil des Compilers ist maschinenunabh"angig programmiert,
aber diejenigen Programmteile, die den tats"achlichen Maschinencode
erzeugen, m"ussen f"ur jede Maschine extra implementiert werden.

Alle diese abh"angigen Teile habe ich im Verzeichnis 'sysdep' zusammen-
gefa"sst (und sysdep selbst ist ein symbolischer Link auf das entsprechende
Verzeichnis der tats"achlichen Architektur, so dass nur mehr dieser Link
umgesetzt werden muss, damit das Programm auf einem anderen Rechner
compiliert werden kann).

Im Verzeichnis 'comp' gibt es folgende systemabh"angige Programmteile:
(diese Dateien sind als Links in das Verzeichnis 'sysdep' realisiert)

	reg.c ..... Registerbelegung
	gen.c ..... generieren von Maschinencode
	disass.c .. Disassembler (nur f"ur Debug-Zwecke)
	

-------------------------------------------------------------------------------
1. Der Registerallokator  (reg.c)
-------------------------------------------------------------------------------

Die Pseudoregister, die vom Compiler bei allen Operationen verwendet werden,
m"ussen irgendwann mit tats"achlichen CPU-Registern belegt werden.

Die Belegung funktioniert nach folgendem Prinzip:
	
Immer, wenn der Compiler ein CPU-Register f"ur eines seiner
Pseudoregister ben"otigt, ruft er eine entsprechende Funktion des
Allokators auf. Diese erzeugt eine 'reginfo'-Struktur, die die 
Information f"ur ein Register enth"alt (Typ INT/FLOAT, Registernummer,
Auslagerungsinformation...).
Der Inhalt der 'reginfo'-Struktur ist f"ur den systemunabh"angigen
Compiler nicht von Bedeutung (wird also sozusagen als opaker Datentyp
behandelt).
Wenn irgendwann nicht mehr genug CPU-Register zur Verf"ugung stehen,
dann darf der Allokator Register auch in den Speicher (also auf den
Stack) auslagern. Er muss dazu einfach eine entsprechende 'reginfo'-
Struktur erzeugen, die dann eben den Offset im Stackframe und
alle n"otigen Zusatzinformationen enth"alt.

	
Die Funktionen im einzelnen sind:

void reg_init ()
	initialisiert den Registerallokator

	
reginfo *reg_allocate(u2 type, bool saved, bool new)
	erzeugt eine reginfo-Struktur mit den entsprechenden Eintr"agen.
	(Diese Datenstruktur muss am DUMP-Speicher [siehe Toolbox-Beschreibung]
	angelegt werden, damit sie irgendwann sp"ater automatisch freigegeben
	wird)

	Das so belegte Register muss verschiedene Voraussetzugen erf"ullen:
	- Es muss ein Datum vom Java-Typ type 
	  (= TYPE_INT/TYPE_LONG/TYPE_FLOAT/TYPE_DOUBLE/TYPE_ADDRESS) 
	  aufnehmen k"onnen
	- Wenn saved=true, dann darf das Register w"ahrend Funktionsaufrufen
	  nicht zerst"ort werden.
	- Wenn new=true, dann darf das Register noch NIE vorher vergeben 
	  worden sein.
	
	Alle so mit 'reg_allocate' belegten Register werden f"ur nachfolgende
	Aufrufe von 'reg_allocate' gesperrt, sie d"urfen also nicht zweimal
	hintereinander vergeben werden (eh klar!).
	    
	Diese Funktion muss IMMER eine g"ultige 'reginfo'-Struktur erzeugen,
	auch wenn vielleicht keine normalen Register mehr "ubrig sind. In 
	solchen F"allen muss eben ein auf den Speicher ausgelagertes 
	Register erzeugt werden.
	 
	 
void *reg_free(reginfo *r)
	Gibt ein durch reg_allocate angefordertes Register tempor"ar wieder
	frei. Dabei darf die 'reginfo'-Struktur aber NICHT zerst"ort werden,
	weil sie vom Compiler sp"ater wieder gebraucht wird.
	Das solchermassen frei gewordene CPU-Register (nicht diese reginfo-
	Struktur) darf aber bei einem folgendem Aufruf von reg_allocate 
	wieder vergeben werden.


bool reg_reallocate (reginfo *r)
	versucht ein schon einmal angefordertes (aber in der Zwischenzeit 
	wieder freigegebenens) Register neuerlich anzufordern. 
	Wenn das Register immer noch unbenutzt ist, dann ist alles OK 
	(R"uckgabewert true), sonst wird 'false' zur"uckgeben, und aus der
	neuerlichen Belegung wird nichts. In diesem Falle wird der Compiler
	versuchen, mit 'reg_allocate' ein ganz neues Register anzufordern.

 
void reg_display (reginfo *r)
	dient nur zu Debug-Zwecken, und gibt eine lesbare Darstellung des
	mit 'reginfo' beschriebenen Registers auf 'stdout' aus.


 	
Die nachfolgenden Funktionen sind f"ur die Optimierung der Funktionsaufrufe,
bzw. der Registerbenutzung im Zusammenhang mit Funktionsaufrufen bestimmt.
Jede dieser Funktionen darf entweder NULL zur"ckliefern (als allererste
nichtoptimierte Version), oder aber eine entsprechende 'reginfo'-Struktur.
 
 
reginfo *reg_parlistresult(u2 type)
	erzeugt eine 'reginfo'-Struktur (auf dem DUMP), die das CPU-Register
	beschreibt, mit den normalerweise ein Datum vom Typ type von
	Funktionen zur"uckgeliefert wird.
	Diese Funktion wird auch schon vor dem Aufruf von 'reg_init' verwendet,
	Diese Funktion selbst blockiert noch kein Register, und sie braucht auch 
	keine R"ucksicht auf irgendwelche schon durchgef"uhrten Registerbelegungen 
	nehmen. Die tats"achliche Allokation wird sp"ater mit einem Aufruf
	von 'reg_reallocate' versucht.
	
reginfo *reg_parlistexception()
	erzeugt eine 'reginfo'-Struktur (auf dem DUMP), die das CPU-Register
	beschreibt, mit den normalerweise der Zeiger auf eine Exception von
	Funktionen zur"uckgeliefert wird.
	Ansonsten v"ollig analog zu 'reg_parlistresult'

reginfo *reg_parlistpar(u2 type)
	erzeugt eine 'reginfo'-Struktur (auf dem DUMP), die das CPU-Register
	beschreibt, mit dem normalerweise ein Datum vom Typ type als Parameter
	an eine Funktion "ubergeben wird.
	Diese Funktion wird im allgemeinen mehrmals hintereinander aufgerufen,
	n"amlich f"ur jedes gew"unschte Parameterregister einmal.
	Jede solche Sequenz wird mit 'reg_parlistinit' eingeleitet.
	Ansonsten funktioniert diese Funktion wie 'reg_parlistresult'.
	Achtung: Diese Funktion sollte gegebenenfalls auch maximale Anzahl
	  der Parameter bei Funktionsaufrufen notieren, wenn diese Information
	  sp"ater vom Codegenerator gebraucht wird.
	 
void reg_parlistinit ()
	Setzt den Parameterz"ahler, den die Funktion 'reg_parlistpar' intern
	ben"otigen wird, auf 0.


-------------------------------------------------------------------------------
2. Der Codegenerator (gen.c)
-------------------------------------------------------------------------------

Der Compiler erzeugt im ersten Durchgang eine systemunabh"angige Darstellung
einer Methode (Operationen mit Quell- und Ziel(pseudo)registern).
Im zweiten Durchgang werden alle Pseudoregister mit tats"achlichen Registern
belegt (siehe oben), und
im dritten Durchgang wird der tats"achliche Code erzeugt (eben durch
den Codegenerator).

Der Codegenerator besteht aus mehreren Teilen:


void gen_computestackframe()
	berechnet das Memory-Layout des Stackframe f"ur die Methode.
	Dabei m"ussen alle Register, die vom Register-Allokator vergeben
	worden, sind und die Anzahl der zu sichernden Register und
	die maximale Anzahl der Parameter ber"ucksichtigt werden.

void gen_header()
	erzeugt den Kopf der Methode (Anlegen des Stackframes, sichern von 
	Registern, holen der Parameter vom Stack oder von Registern, etc..)
	
void gen_pcmd (pcmd *c)
	erzeugt zu einem Pseudo-Kommando den entsprechenden Maschinencode.
	Eine Beschreibung der pcmd-Struktur und aller f"ur den Codegenerator
	relevanten globalen Variablen und Funktionen sind weiter unten beschrieben.
	
void gen_resolvebranch ( void* mcodepiece, u4 sourcepos, u4 targetpos)
	tr"agt eine tats"achlien Sprungadresse in den vorher erzeuten
	Maschinencode ein (Backpatching). 
	Parameter: mcodepiece ... Zeiger in den Speicher, wo der entsprechende
	                          Sprungbefehl steht
	           sourcepos .... relative Adresse des Sprungbefehls in Byte
	                          (vom Methodenbeginn an gerechnet)
	           targetpos .... relative Adresse des Sprungziels in Byte
	                          (vom Methodenbeginn an gerechnet)


Alle Literale, die der Codegenerator erzeugt (konstante Integers,
Addressen,...) werden in einem direkt VOR dem Codesegment liegenden
Datensegment gespeichert.
Dabei w"achst das Datensegment von oben nach unten, und das Codesegment
von unten nach oben.
Die Addressierung sowohl des Codes, als auch der Daten kann dann
"uber ein einziges Basisregister (auf der ALPHA ist das das Register
 R27 = PV ).
Der Codegenerator greift auf diese beiden Segmente nur "uber spezielle
Funktionen zu, die den Speicher f"ur die Segmente gegebenenfalls 
vergr"ossern k"onnen.
Am Ende der Generierung wird ein dann einziger Speicherblock angelegt,
wo beide Segmente passgenau hineingeschrieben werden.
 

3. Der Disassembler (disass.c)
-------------------------------------------------------------------------------

Der Disassembler dient nur zu Debug-Zwecken und kann durch eine Dummy-Funktion
ersetzt werden.

Der Disassembler hat nur eine Funktion:

disassemble(u4 *code, u4 len)
	erzeugt ein lesbares Listing der Maschinenbefehle, die im Speicher 
	an der angegebenen Stelle stehen. Die L"ange des Maschinenprogrammes
	wird hier in BYTE angegeben.
	Das Listing wird auf 'stdout' ausgegeben.
		 


------------------------------------------------------------------------------
Beschreibung der globalen Variablen und Methoden
------------------------------------------------------------------------------

Der Codegenerator braucht f"ur seine Arbeit einige Funktionen und 
Variablen, die im systemUnabh"angigen Teil bereits zur Verf"ugung stehen.


Funktionen
----------

mcode_addu4 (u4 codepiece)
	f"ugt zum aktuell erzeugten Codesegment ein 32-Byte-Wort hinzu.
	Damit sollten sich alle Maschinenbefehle (zumindest f"ur RISC) 
	erzeugen lassen.
	
s4 dseg_adds4 (s4 value)
s4 dseg_adds8 (s8 value)
s4 dseg_addfloat (float value)
s4 dseg_adddouble (double value)
s4 dseg_addaddress (void *value)
	diese Funktionen f"ugen das entsprechende Datum zum Datensegment
	der Methode hinzu. Das Alignment wird auf jeden Fall richtig 
	behandelt.
	
	Alle diese Funktionen liefern als R"uckgabewert den Offset des 
	Datenelements innerhalb des Datensegments zur"uck. Weil das Datensegment
	direkt vor dem Codesegment liegt, und alle Addressierungen
	relativ zum Methodenanfang (also zum Anfang des Codes) passieren,
	sind diese Offsets immer negativ.

s4 dseg_addtarget (basicblock *target)
	funktioniert im Prinzip so wie die obigen Funktionen, allerdings
	wird in das Datensegment ein Zeiger auf eine Codeposition (deren
	genaue Adresse aber noch gar nicht feststeht) eingetragen.
	Die tats"achliche Adresse wird ganz am Ende der Codeerzeugung 
	automatisch	an die richtige Stelle geschrieben, so dass beim 
	Programmlauf auf jeden Fall der richtige Wert dort steht.
	(Diese Funktion wird wahrscheinlich vor allem f"ur Sprungtabellen
	von Bedeutung sein)
	

void mcode_addreference (basicblock *target)
	Mit dieser Funktion macht der Codegenerator einen Eintrag in die
	Liste der der sp"ater zu vervollst"andigenden Sprungbefehle.
	Die Vorgehensweise ist folgende:
	- Wenn der Codegenerator ein (Vorw"arts-)Sprunganweisung erzeugen will,
	  dann ruft er VORHER mcode_addreference auf (als Parameter
	  die entsprechende basicblock-Struktur)
	- Dann erzeugt der Codegenerator einen Sprungbefehl (mit mcode_addu4), 
	  l"asst dabei aber die Zieladdresse leer (weil sie ja noch nicht 
	  feststeht)
	- sobald der Code fertig erzeugt worden ist (und alle Sprungziele 
	  feststehen) wird f"ur jeden so vorbereiteten Sprungbefehl die
	  Funktion gen_resolvebranch (Dokumentation siehe dort) aufgerufen.

	  

Globale Variablen
-----------------

bool isleafmethod
	zeigt an, dass die Methode eine Leaf-Methode ist, d.h, dass sie keine
	weiteren Methoden oder Funktionen aufruft

u2 mparamnum 
	die Anzahl der Parameter f"ur die Methode, inklusive dem 
	this-Zeiger (aber um den this-Zeiger braucht sich der Codegenerator
	sowieso nicht extra k"ummern)

u2 *mparatypes
	ein Zeiger auf ein Array von Integers, die die Java-Grundtypen 
	(TYPE_INT, TYPE_LONG,...) der Parameter angeben

u2 mreturntype
	gibt den Java-Grundtyp des R"uckgabewertes an (TYPE_INT, TYPE_LONG)
	oder bei Methoden ohne R"uckgabewert: TYPE_VOID

varinfo **mparamvars
	ein Zeiger auf ein Array von Zeigern auf die varinfo-Strukturen.
	Diese varinfos geben die Pseudoregister an, in die die Parameter
	der Methode nach dem Aufruf geschrieben werden sollen (der Code
	f"ur dieses (eventuell n"otige) Umladen der Werte muss von
	gen_header erzeugt werden).
	
	
------------------------------------------------------------------------------
die varinfo-Struktur
------------------------------------------------------------------------------

In den Pseudocommandos (pcmd) stehen als Operanden immer Verweise auf 
Pseudoregister, denen w"ahrend der Registerbelegungsphase echte
Maschinenregister zugewiesen werden.
F"ur den nachfolgenden Codegenerator ist dann nur mehr das entsprechende
Maschinenregister von Bedeutung. 
Der Codegenerator darf in der varinfo-Struktur nur auf das Feld 
'reg' zugreifen, das einen Zeiger auf die entsprechende 'reginfo'-Struktur
(wie sie vom Registerallokator erzeugt worden ist -> siehe oben) enth"alt.
Der Codegenerator kann sich darauf verlassen, dass jeder varinfo-Struktur,
die "uber ein pcmd erreichbar ist, auch ein entsprechendes reginfo zugewiesen
wurde.



------------------------------------------------------------------------------
Die pcmd-Struktur
------------------------------------------------------------------------------

Hier finden sich alle Informationen, die die Funktion 'gen_pcmd' 
braucht, um damit Maschinencode f"ur ein Pseudokommando zu erzeugen.
Die Syntax dieser Struktur (mit Kommentaren) befindet sich unter anderem
in der Datei 'defines.c'.

F"ur verschiedene Typen von Kommandos muss die Struktur verschiedene
Daten enthalten, deshalb ist sie mit Hilfe einer 'union' realisiert,
und ein tag-Feld gibt den tats"achlichen Typ der Struktur an (jaja, in
C gibt es eben keine abgeleiteten Datentypen ...).
Die Werte und Bezeichnung f"ur dieses Tag-Feld steht ebenfalls in der 
Datei 'defines.c'


Beschreibung der allgemeinen Felder der 'pcmd'.

	linkage ... interne Verkettung, f"ur den Codegenerator ohne Bedeutung)
	tag ....... Kennzeichnung des Typs des Kommandos
	
	dest ...... Pseudoregister f"ur eine optionalen Zieloperanden
	source1 ... Pseudoregister f"ur den 1. optionalen Quelloperanden
	source2 ...                         2.
	source3 ...                         3.
	
Alle Kommandos (ausser unbedingten Spr"ungen) haben in irgendeiner Form
Operanden-Register. Dabei stehen Register aus denen ein Wert geholt wird
in den Feldern source1-source3, und ein Register in das ein Wert geschrieben
wird, steht im Feld dest. Alle unbenutzen Felder haben immer den
Wert NULL.

Alle Befehle haben eine genau definierte Anzahl von Operanden, deren
Typ ausserdem auf jeden Fall stimmt (die Register wurden zuvor mit
'reg_allocate' unter Angabe des richtigen Typs angefordert).


Die Befehlstypen
----------------

	LOADCONST_I
	LOADCONST_L
	LOADCONST_F
	LOADCONST_D
	LOADCONST_A 
		Jeder dieser Befehle l"adt einen Wert vom entsprechenden
		Typ in das Zielregister.
		Diese konstanten Werte selber stehen in 
		pcmd->i.value, pcmd->l.value ...
		
	MOVE
		Kopiert einen Wert vom Quellregister 1 ins Zielregister.
		Beide Register haben den Typ pcmd->move.type .
		
	OP
		F"uhrt eine JavaVM-Grundoperation aus.
		Im Feld pcmd->op.opcode steht der JavaVM-Opcode des gew"unschten
		Befehls.
		Die Anzahl und die Typen der Operanden sind f"ur jede Operation
		anders. Eine genaue Beschreibung der Semantik findet sich
		in der JavaVM-Spezifikation. Dabei sind die Quelloperanden
		in der Reihenfolge wie sie in der Spezifikation am Stack stehen
		(von links nach rechts), in die Quellregister 1 bis 3 aufgeteilt.
		Bei Operanden vom Typ LONG oder DOUBLE sind beide 'value-words'
		in einem Register zusammengefasst.

	MEM
		L"adt entweder einen Wert aus dem Speicher, oder schreibt
		einen Wert dorthin.
		Das Feld pcmd->mem.opcode enth"alt dazu entweder CMD_GETFIELD
		oder CMD_PUTFIELD.
		In pcmd->mem.type steht der Java-Grunddatentyp dieses
		Feldes, und in pcmd->mem.offset steht der konstante Offset (in Byte),
		der zum Basisregister (pcmd->source1) addiert werden soll, um die 
		tats"achliche Speicheradresse des Felds zu bekommen.
		Bei Ladeoperationen steht das Ergebnis nachher im Register 
		pcmd->dest, bei Speicheroperationen steht der zu speichernde
		Wert im Register pcmd->source2.
		
	BRA
		F"uhrt bedingte oder unbedingte Spr"unge aus. Im Feld 
		pcmd->bra.opcode steht der entsprechende JavaVM-Opcode.
		Die Operanden (die laut JavaVM-Spec am Stack stehen m"ussen)
		sind in den Registern pcmd->source1 und pcmd-source2 zu finden
		(ganz analog zu dene OP-Kommandos).
		Spezielle Formen: 
			JSR: Hier soll die R"ucksprungadresse ins Register pcmd-dest
			     geschrieben werden.
			RET: Obwohl laut JavaVM-Spec dieser Befehl den Stack nicht
			     beeinflusst, hat er dennoch einen Operanden: pcmd->source1
			     enth"alt die R"ucksprungadresse 
				
			IRETURN bis ARETURN
			und RETURN:
				 in pcmd->source1 befindet sich der R"uckgabewert
				 (ausgenommen bei RETURN), und
				 in pcmd->source2 ist der Zeiger auf die zu werfende
				 Exception.
	
		Das Sprungziel (insofern bei dem Befehl eines m"oglich ist) wird
		als Zeiger auf eine basicblock-Struktur "ubergeben. 
		Zum Aufl"osen der Sprungziele siehe: mcode_addreference.
		
	TABLEJUMP
		Fu"hrt eine Programmverzweigung "uber eine Sprungtabelle durch.			
		Der einzige Operand (pcmd->source1) ist im Bereich von
		i = 0 .. pcmd->tablejump.targetcount-1. Der Befehl soll an das
		dementsprechende Sprungziel pcmd->tablejump.targets[i] verzweigen.
		Zur Konstruktion einer Sprungtabelle siehe: dseg_addtarget.


	METHOD
		F"uhrt einen Methoden (bzw. C-Funktions-) -aufruf durch. 
		Die Felder pcmd->method.paramnum und pcmd->method.params[..] 
		geben die Anzahl und die Register an, in denen die Parameter
		stehen. Unter (g"unstigen) Umst"anden sind einige der Register
		schon diejenigen, die durch die Aufrufkonventionen die Parameter
		enthalten sollen (wenn das nicht der Fall ist, dann m"ussen
		die Werte vor dem Aufruf noch umgeladen werden).
		Das Feld pcmd->method.exceptionvar enth"alt (wenn es nicht
		NULL ist) die Variable, in der eine allf"allig aufgetretene
		Exception zur"uckerwartet wird.
		Der normale R"uckgabewert der Methode soll ins Register
		pcmd->dest geschrieben werden.

		Dieses Pseudokommando wird sowohl f"ur Aufrufe von normalen
		C-Funktionen (dann steht im Feld pcmd->method->builtin der
		Zeiger auf diese Funktion) als auch f"ur Aufrufe von Java-Methoden
		verwendet (dann steht im Feld pcmd->method->builtin der 
		Wert NULL).
		
		Im zweiten Fall enth"alt das Feld pcmd->method->method einen
		Zeiger auf die methodinfo-Struktur der gew"unschten Methode.
		Bei Aufrufen vom Typ INVOKESTATIC und INVOKESPECIAL 
		(der Typ steht in pcmd->method->opcode) braucht dazu nur
		der Funktionszeiger von dort geladen werden. 
		Bei INVOKEVIRTUAL und INVOKEINTERFACE muss der Funktionszeiger
		aus der Virtual Function Table der Klasse des tats"achlichen 
		Objektes geholt werden. Der Zeiger auf dieses Objekt ist immer
		im Register pcmd->method->params[0] zu finden.
		Eine Beschreibung dieser Tabellen steht in der Datei "global.h".
		
		WICHTIG: Dieses System compiliert alle Methoden beim ersten 
			Aufruf, deshalb m"ussen alle Methodenaufrufe immer mit dem
			Umweg "uber die methodinfo-Struktur passieren, weil nur dort
			dann der tats"achliche Funktionszeiger eingetragen wird.
			Wenn die Methode n"amlich noch nicht aufgerufen wurde, dann 
			steht dort ein Zeiger auf den Compiler selbst.
			Der Compiler ben"otigt f"ur seine Arbeit aber noch zus"atzlich
			den Zeiger auf die methodinfo-Struktur in einem fixen
			Register. Auf der DEC-ALPHA verwende ich hier das Register 28.
			Die Aufrufsequenz auf der DEC-ALPHA f"ur einen normalen
			INVOKESTATIC-Aufruf w"urde ungef"ahr so aussehen:
				
				LDQ (28, 27, position_des_methodinfo_zeigers_im_datensegment)
				LDQ (27, 28, OFFSET(methodinfo, func) )
				JSR (26, 27)
				LDA (27, 26, -position_dieses_befehls_im_code)
		
		
		

-------------------------------------------------------------------------------
Anhang: Notwendige Opcodes

F"ur die Befehle vom Typ OP m"ussen folgende Opcodes unterst"utzt werden:
		 CMD_INEG
		 CMD_LNEG
		 CMD_FNEG
		 CMD_DNEG
		 CMD_I2L
		 CMD_L2I
		 CMD_INT2BYTE
		 CMD_INT2CHAR
		 CMD_INT2SHORT
		 CMD_IADD
		 CMD_LADD
		 CMD_FADD
		 CMD_DADD
		 CMD_ISUB
		 CMD_LSUB
		 CMD_FSUB
		 CMD_DSUB
		 CMD_IMUL
		 CMD_LMUL
		 CMD_FMUL
		 CMD_DMUL
		 CMD_FDIV
		 CMD_DDIV
		 CMD_FREM
		 CMD_DREM
		 CMD_ISHL
		 CMD_ISHR
		 CMD_IUSHR
		 CMD_LSHL
		 CMD_LSHR
		 CMD_LUSHR
		 CMD_IAND
		 CMD_LAND
		 CMD_IOR
		 CMD_LOR
		 CMD_IXOR
		 CMD_LXOR
		 CMD_I2F
		 CMD_L2F
		 CMD_I2D
		 CMD_L2D
		 CMD_F2I
		 CMD_D2I
		 CMD_F2L
		 CMD_D2L
		 CMD_F2D
		 CMD_D2F
		 CMD_LCMP
		 CMD_FCMPL
		 CMD_DCMPL
		 CMD_FCMPG
		 CMD_DCMPG
		 CMD_ARRAYLENGTH
		 CMD_AALOAD
		 CMD_LALOAD
		 CMD_IALOAD
		 CMD_FALOAD
		 CMD_DALOAD
		 CMD_CALOAD
		 CMD_SALOAD
		 CMD_BALOAD
		 CMD_AASTORE
		 CMD_LASTORE
		 CMD_IASTORE
		 CMD_FASTORE
		 CMD_DASTORE
		 CMD_CASTORE
		 CMD_SASTORE
		 CMD_BASTORE

F"ur die Befehle vom Typ MEM m"ussen folgende Opcodes unterst"utzt werden:
		 CMD_PUTFIELD:
		 CMD_GETFIELD:


F"ur die Befehle vom Typ BRA m"ussen folgende Opcodes unterst"utzt werden:
		 CMD_GOTO
		 CMD_JSR
		 CMD_RET
		 CMD_IFEQ
		 CMD_IFNULL
		 CMD_IFLT
		 CMD_IFLE
		 CMD_IFNE
		 CMD_IFNONNULL
		 CMD_IFGT
		 CMD_IFGE
		 CMD_IF_ICMPEQ
		 CMD_IF_ACMPEQ
		 CMD_IF_ICMPNE
		 CMD_IF_ACMPNE
		 CMD_IF_ICMPLT
		 CMD_IF_ICMPGT
		 CMD_IF_ICMPLE
		 CMD_IF_ICMPGE
		 CMD_IRETURN
		 CMD_LRETURN
		 CMD_ARETURN
		 CMD_FRETURN
		 CMD_DRETURN
		 CMD_RETURN



F"ur die Befehle vom Typ METHOD m"ussen folgene Opcodes unterst"utzt werden:
		 CMD_INVOKESTATIC
		 CMD_INVOKESPECIAL
		 CMD_INVOKEVIRTUAL
		 CMD_INVOKEINTERFACE
