/*************************** doc/collect.doc ***********************************

	Copyright (c) 1997 A. Krall, R. Grafl, M. Gschwind, M. Probst

	See file COPYRIGHT for information on usage and disclaimer of warranties

	Enth"alt die Beschreibung des Garbage Collectors

	Authors: Reinhard Grafl      EMAIL: cacao@complang.tuwien.ac.at

	Last Change: 1996/11/14

*******************************************************************************/

Generell:

F"ur den CACAO habe ich einen recht einfachen Mark and Sweep - Collector
implementiert, mit dem der Speicher immer dann ges"aubert wird, wenn
eine Anforderung nicht zufriedenstellend durchgef"uhrt werden
kann (im Klartext: der GC l"auft NICHT in einem eigenen Thread).

Der Heap ist ein einziger Speicherblock, der gleich zu Programmstart
angelegt wird, und dessen Gr"osse sich nicht mehr "andern kann.
(also immer gleich gen"ugend Speicher anlegen! Bei Maschinen mit 
virtuellem Speicher sollte das kein Problem sein)

Der Collector verschiebt keine Objekte im Speicher, und er kommt mit
minimaler Information "uber die innere Struktur der Objekte aus
(um es pr"aziser zu sagen: Der GC nimmt bei allen Daten einmal an,
dass es sich dabei um Zeiger auf Objekte in den Heap handelt. Wenn
irgendwelche Zahlen z"uf"allig einen g"ultigen Zeiger auf ein Objekt
darstellen, dann wird dieses Objekt eben nicht freigeben.)

Der Heap ist in kleine unteilbare Einheiten aufgeteilt, die nur immer
als ganzen vergeben werden k"onnen (Heap-Bl"ocke), deren Gr"osse
auf jeden Fall die in Java n"otigen Alignment-Bedingungen erf"ullt.


Notwendige zus"atzliche Datenstrukturen
---------------------------------------

Der GC muss auf jeden Fall wissen, wo im Heap g"ultige Objekte stehen
(damit die Markierung mit m"oglicher- (aber nicht notwendigerweise) 
g"ultigen Zeigern richtig funktioniert).

Dazu verwaltet er ein Bitfeld ('startbits'), in dem f"ur jeden Heap-Block
eintr"agt, ob an der Stelle ein Objekt anf"angt. Zu"atzlich werden auch
alle FREIEN Speicherbereiche mit so einem Bit markiert.

Ein zweites Bitfeld ('referencebits') gibt an, ob in dem Objekt, das 
an der Stelle anf"angt, noch weitere Referenzen auf andere Objekte 
gespeichert sein k"onnen.
(Damit die Markierungsphase fr"uhzeitig abgebrochen werden kann)

Beispiel:

Heap:          | Obj1 |  Obj2 |     frei     | Obj3 | Obj3 |  frei   |
               -------------------------------------------------------

startbits:     100000010000000100000000000000100000010000001000000000

referencebits: 100000000000000000000000000000100000000000000000000000


(in obigem Beispiel k"onnten Obj1 und Obj3 noch weitere Referenzen
enthalten)

Man beachte: Die Bitfelder werden nur soweit benutzt, als tats"achlich 
schon Platz am Heap vergeben worden ist (wird mit Hilfe einer globalen
Variable 'topofheap' gehandhabt). Alle dar"uberhausgehenden Bits sind
noch 0. Das letzte Objekte im Heap (oder der freie Speicherbereich)
wird also nicht mit so einem 1-Bit abgeschlossen.


Vorgangsweise beim Anlegen eines neuen Objektes
-----------------------------------------------

In einer Freispeicherliste sind alle freien Bereiche eingetragen 
(die Freispeicherlisten verwenden dabei gleich den freien Speicher 
f"ur die notwendige Verkettung).
Zuerst muss beliebiger passender Bereich gesucht werden.

1. Fall: Bereich hat genau die richtige Gr"osse
	- Aus der Freispeicherliste austragen
	- gegebenenfalls das zugeh"orige Bit im Feld 'referencebits' 
	  setzen
	- fertig
	
2. Fall: Bereich ist gr"osser als notwendig
	- Aus der Freispeicherliste austragen.
	- In Liste das Restst"uckchen eintragen
	- Ein Bit im Bitfeld 'startbits' eintragen, wo der neue freie 
	  Speicher anf"angt.
	- gegebenenfalls das dem neuen Objete zugeh"orige Bit im Feld 
      'referencebits' setzen
	- fertig
	
3. Fall: Es ist kein freier Bereich mehr in der Freispeicherliste
	- das neue Objekte wird ganz oben am Heap angelegt
	- Bit im Bitfeld 'startbits' am der Stelle 'topofheap' eintragen.
	- den 'topofheap'-Z"ahler im die Objektel"ange erh"ohen 
	- eventuell ein Bit in 'referencebits' setzen
	- fertig
	
4. Fall: Es ist zuwenig Speicher mehr oben im Heap "ubrig
	- Garbage Collection durchf"uhren
	- alles nocheinmal probieren
	

Vorgangsweise zur Garbage Collection
------------------------------------

Ein drittes Bitfeld ('markbits') wird ben"otigt, das zuerst mit
0 initialisiert wird.

In der Markierungsphase werden alle Objekte durchgegangen, die
von irgendwo im Stack oder von globalen Variablen aus erreichbar
sind.
Ein Zeiger zeigt tats"achlich auf ein g"ultiges Objekt im Heap, wenn:
	- Der Zeiger in den Bereich des Heap zeigt
	- Der Zeiger richtiges Alignment hat (auf Blockgr"osse)
	- Das zugeh"orige Bit in 'startbits' gesetzt ist

Wenn das der Fall ist, und das Bit in 'markbits' noch nicht gesetzt ist,
dann wird dieses Bit jetzt gesetzt, und wenn noch dazu das Bit in
'referencebits' gesetzt ist, dann werden alle Referenzen vom Objekt
rekuriv ebenfalls markiert.
Die L"ange des Objektes erf"ahrt man aus dem 'startbits'-Feld. Man muss
nur den n"achsten 1er suchen (oder vorher abbrechen, wenn man die
Stelle 'topofheap' erreicht).


Beispiel:

Heap:          | Obj1 |  Obj2 |     frei     | Obj3 | Obj4 |  frei   |
               -------------------------------------------------------

startbits:     100000010000000100000000000000100000010000001000000000
markbits:      000000010000000000000000000000100000010000000000000000

referencebits: 100000000000000000000000000000100000000000000000000000

In dem Beispiel wurden nur mehr Obj2 und Obj3 als erreichbar erkannt,
die anderen Objekte wurden nicht erreicht. 

Anmerkung: Es k"onnte hier passieren, dass ein freier Speicherbereich 
	irrt"umlich als Objekte markiert und f"ur den folgenden
	Sweep-Durchlauf blockiert wird. Das sollte aber nur SEHR selten 
	vorkommen.


Nach der Markierungsphase sieht man schon, dass einige Objekte
weggeworfen werden sollen. Damit die zu diesen Objekte geh"orenden
'referencebits' ebenfalls gel"oscht werden, braucht man nur
ein logisches UND der beiden Bitfelder 'markbits' und 'referencebits'
durchf"uhren, und das Ergebnis in 'referencebits' speichern.

Obiges Beispiel:

markbits:      000000010000000000000000000000100000010000000000000000
referencebits: 100000000000000000000000000000100000000000000000000000
---------------------------------------------------------------------
         UND   000000000000000000000000000000100000000000000000000000	
         




F"ur die Sweep-Phase wird der gesammte Bereich linear durchgegangen,
und alle freien Bereiche in die Freispeicherliste eingeh"angt.

Dazu wird der Anfang des ersten freien Bereiches gesucht, und zwar indem
nach der erste Stelle gesucht wird, an der ein startbit GESETZT ist,
aber das markbit NICHT gesetzt ist.
Das Ende des freien Bereiches findet man dort, wo das n"achste
markbit GESETZT ist.
(dabei werden auch automatisch hintereinanderliegenden Speicherst"ucke
zusammengefasst)
Den gesammten Bereich kann man jetzt in die Freispeicherliste einh"angen,
und gleichzeitig muss noch ds markbit, an dem der Bereich anf"angt,
gesetzt werden (wozu, das wird weiter unten erkl"art)

F"ur alle folgenden Bl"ocke geht man genauso vor, bis das Ende des
Heaps erreicht ist.
Die oben erw"ahnten Bit-Suche-Operationen gehen - wenn man sie gut
implementiert - relativ rasch (z.B. mit 64-Bit-Operationen auf einer
DEC-Alpha).


Der Grund, warum man alle freien Bereiche mit einem zus"atzlichen
Markierungsbit versieht ist der, dass jetzt zu Ende des Sweep in
'markbits' genau diejenige Bits stehen, die eigentlich auch in 
'startbits' geh"oren, n"amlich eine Kennzeichnung aller lebenden
Objekte und aller Freispeicherbereiche.


Fortsetzung des obigen Beispiels:

Heap:          | frei |  Obj2 |     frei     | Obj3 |  frei          |
               -------------------------------------------------------

startbits:     100000010000000100000000000000100000010000001000000000
markbits:      100000010000000100000000000000100000010000000000000000

referencebits: 000000000000000000000000000000100000000000000000000000


Durch einfaches Umkopieren der 'markbits' auf die 'startbits' 
(oder noch besser: durch Austauschen der beiden Zeiger) ist der
Garbage-Collection-Durchlauf abgeschlossen.


