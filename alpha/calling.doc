/***************************** calling.doc *************************************

	Copyright (c) 1997 A. Krall, R. Grafl, M. Gschwind, M. Probst

	See file COPYRIGHT for information on usage and disclaimer of warranties

	Das ist eine kurze Dokumentation "uber die internen Aufrufskonventionen
	der Java-Methoden in der DEC-ALHPA-Version.

	Author:  Reinhard Grafl      EMAIL: cacao@complang.tuwien.ac.at

	Last Change: 1997/02/05

*******************************************************************************/
FILE: calling.doc

Das ist eine kurze Dokumentation "uber die internen Aufrufskonventionen
der Java-Methoden in der DEC-ALHPA-Version.

-------------------------------------------------------------------------------


Die Aufrufskonventionen halten sich weitgehende an die Konventionen
f"ur normale C-Funktionen, allerdings mit einigen zus"atzlichen
Registerbelegungen:

R28 ..... enth"alt bei einem Methodenaufruf auf jeden Fall den Zeiger 
          auf die zugeh"orige 'methodinfo'-Struktur, die gegebenenfalls an
          den JIT-Compiler weitergegeben werden muss. 

          Wenn von Java-Methoden aus direkt C-Funktionen aufgerufen werden,
          (f"ur die nat"urlich auch keine 'methodinfo'-Struktur existiert),
          dann hat dieses Register keinen definierten Wert (Alle von der
          JavaVM verwendeten Funktionen, z. B. 'builtin_new', etc. werden
          so aufgerufen)
          
R1 ...... enth"alt nach Methodenbeendigung entweder NULL oder einen Zeiger
          auf ein Objekt vom Typ java.lang.Throwable (oder einem davon
          abgeleiteten Typ).
          Wenn das der Fall ist, dann wurde in der Methode eine Exception
          geworfen, die nicht abgefangen werden konnte, und jetzt beim
          Aufrufer weiter bearbeitet werden muss.


          
Die restlichen Register folgen den normalen Konventionen, aber ich gebe
hier noch einmal eine kurze "Ubersicht:

 
INTEGER-REGISTER:

R0 ........ R"uckgabewert von den Methoden f"ur die Typen:
                    INT,LONG,ADDRESS
                    
R1 ........ Adresse der geworfenen Exception (oder NULL)

R2-R8 ..... tempor"are Register (werden im Unterprogram zerst"ort)

R9-R15 .... gesicherte Register (werden im Unterprogramm nicht ver"andert)

R16-R21 ... Argumentregister 1 - 6 (hier werden die ersten sechs Methoden- 
            Argumente eingetragen, sofern sie von den Typen INT,LONG,ADDRESS 
            sind. Diese Argumentregister werden im Unterprogramm zerst"ort
           
R22-R24 ... tempor"are Register
            (werden im Unterprogramm zerst"ort)		
		
R25 ....... tempor"ares Register f"ur kurzfristige Zwischenergebnisse
            (wird im Unterprogramm zerst"ort)

R26 (ra) .. R"ucksprungadresse (bleibt im Unterprogramm erhalten)

R27 (pv) .. Prozedurzeiger. Dieses Register muss auf jeden Fall einen Zeiger
            auf die aufgerufene Prozedur enthalten (damit die Zugriffe
            auf das Datensegment funktionieren k"onnen).
            (der Wert bleibt im Unterprogramm erhalten)

R28 ....... Zeiger auf die 'methodinfo' - Struktur. Muss auf jeden Fall bei
            allen Methodenaufrufen richtig gesetzt sein (wegen eines eventuellen
            Compiler-Aufrufs)
            (wird im Unterprogramm zerst"ort)
            
R29 ....... tempor"ares Register f"ur kurzfristige Zwischenergebnisse
            (wird im Unterprogramm zerst"ort)

R30 (sp) .. Zeiger auf die Untergrenze des Stack (der Stack w"achst von
            oben nach unten)
            
R31 ....... enth"alt immer NULL


 
FLIESSKOMMA-REGISTER:


F0 ........ enth"alt die R"uckgabewert der Methoden vom Typ:
                FLOAT, DOUBLE
F1 ........ enth"alt den Imagin"aranteil von einem komplexen Funktionswert
                (wird von mir nicht benutzt)
                                
F2-F9 ..... gesicherte Register (werden im Unterprogramm nicht ver"andert)

F10-F15 ... tempor"are Register (werden im Unterprogramm zerst"ort)

F16-F21 ... Argumentregister f"ur die ersten 6 Parameter, sofern diese
            vom den Typen FLOAT oder DOUBLE sind
            
F22-F24 ... tempor"are Register (werden im Unterprogramm zerst"ort)

F25-F31 ... tempor"are Register f"ur kurzfristige Zwischenergebnisse
            (werden im Unterprogramm zerst"ort)

F31 ....... enth"alt immer 0.0



PARAMETER"UBERGABE AM STACK:

Bei mehr als sechs Parametern reicht der Platz in den Registern nicht mehr
aus, daf"ur werden alle Parameter ab dem Siebenten am Stack "ubergeben,
und zwar nach folgendem Muster:


                  | .....                                          |
				  --------------------------------------------------
                  |  Parameter 9  ( 64 bit, egal bei welchem Typ)  |
                  --------------------------------------------------
				  |  Parameter 8  ( 64 bit, egal bei welchem Typ   |
                  --------------------------------------------------
   R30 (sp) --->  |  Parameter 7  ( 64 bit, egal bei welchem Typ)  |
                  --------------------------------------------------
  
Der Stackpointer zeigt dabei auf die Untergrenze des Parameterbereichs.





VOLLST"ANDIGES LAYOUT EINES STACKFRAMES:

Jede Methode muss (wenn es keine Leaf-Methode ist, auf jeden Fall) gewisse
Registerinhalte am Stack sichern.
Eventuell werden auch noch lokale Werte, die nicht mehr in Registern
Platz finden, ebenfalls am Stack aufbewahrt, und die Parameter"ubergabe
bei mehr als 6 Parametern ben"otigt ebenfalls Platz am Stack.

Ein vollst"andiger Stackframe hat also dieses Aussehen (jeder Eintrag
im Stackframe ist unabh"angig vom Typ auf jedem Fall 64 bit lang, die
Gr"ossenangaben der Bereiche sind in solchen Einheiten von 64 Bit 
angegeben):
	
				---------------------------------------------
				|  Parameter n (vom Aufrufer)               |
                ---------------------------------------------				
				|  Parameter n-1                            |
				---------------------------------------------
                | ...                                       |
                ---------------------------------------------
   SP vorher -> |  Parameter 7                              |
                ============================================= --- 
                |  gesichertes RA                           |  savedregs_num    
                ---------------------------------------------
                |  andere gesicherte Register               |
                ============================================= ---
                |  Platz f"ur lokale Werte, die nicht mehr  |  localvars_num
                |  in Register passen                       |
                ============================================= ---
                |  ....                                     |  arguments_num
                ---------------------------------------------
                |  Parameter 8                              |
                ---------------------------------------------
   SP --->      |  Parameter 7 (f"ur aufgerufenen Methoden) |
                ============================================= ---
               
                
Damit die Anf"ange der einzelnen Bereiche (im Codegenerator) leichter 
ausgedr"uckt werden k"onnen, sind ein paar Hilfsvariablen vorgesehen, die
die Adressierung der einzelnen Bereiche vereinfachen:
	localvars_base  = arguments_num
	savedregs_base  = localvars_base + localvars_num
	parentargs_base = savedregs_base + savedregs_num

